//====================================================
// MONITOR 1: Gestión de buffers de tareas
//====================================================
MONITOR BufferTareas
    // Variables privadas
    buffers: array[N_CONTROLLERS] de tarea
    ocupado: array[N_CONTROLLERS] de boolean  // true si hay tarea, false si hay hueco
    
    // Inicialización
    INIT
        FOR i := 0 TO N_CONTROLLERS-1 DO
            ocupado[i] := false  // Inicialmente todos los buffers tienen hueco
        END FOR
    END INIT
    
    //----------------------------------------------------
    PROCEDURE ponerTarea(t: tarea, id_buffer: int)
        // Esperar a que haya hueco libre
        IF ocupado[id_buffer] THEN
            WAIT  // Bloquear hasta que haya hueco
        END IF
        
        // Depositar la tarea
        buffers[id_buffer] := t
        ocupado[id_buffer] := true
        
        SIGNAL  // Notificar que hay tarea disponible
    END PROCEDURE
    
    //----------------------------------------------------
    PROCEDURE obtenerTarea(id_controller: int): tarea
        // Esperar hasta que haya tarea
        IF NOT ocupado[id_controller] THEN
            WAIT  // Bloquear hasta que haya tarea
        END IF
        
        // Tomar la tarea
        t := buffers[id_controller]
        ocupado[id_controller] := false
        
        SIGNAL  // Notificar que hay hueco libre
        
        RETURN t
    END PROCEDURE
    
END MONITOR

//====================================================
// MONITOR 2: Gestión de resultados
//====================================================
MONITOR GestionResultados
    // Variables privadas
    resultados: array[3][3] de float
    
    // Inicialización
    INIT
        FOR i := 0 TO 2 DO
            FOR j := 0 TO 2 DO
                resultados[i][j] := 0
            END FOR
        END FOR
    END INIT
    
    //----------------------------------------------------
    PROCEDURE registrarEjecucion(tipo_idx: int)
        resultados[tipo_idx][0]++  // Incrementar total ejecutadas
    END PROCEDURE
    
    //----------------------------------------------------
    PROCEDURE registrarExito(tipo_idx: int, carga: float)
        resultados[tipo_idx][1]++  // Incrementar éxitos
        resultados[tipo_idx][2] += carga  // Acumular tiempo
    END PROCEDURE
    
    //----------------------------------------------------
    PROCEDURE obtenerResultados(): array[3][3] de float
        RETURN resultados
    END PROCEDURE
    
END MONITOR

//====================================================
// PROCESOS ACTUALIZADOS CON MONITORES
//====================================================

PROCESS masterTask(monitorBuffer, listaTareas)
    // Asignamos todas las tareas
    FOR i := 0 TO listaTareas.size()-1 DO
        t := listaTareas[i]
        
        colocada := false
        WHILE NOT colocada DO
            FOR j := 0 TO N_CONTROLLERS-1 AND NOT colocada DO
                monitorBuffer.ponerTarea(t, j)
                colocada := true
            END FOR
        END WHILE
    END FOR
    
    // Poner tareas de fin en cada buffer
    tfin := {tipoTarea: "TF", cargaDeTrabajo: 0}
    
    FOR j := 0 TO N_CONTROLLERS-1 DO
        monitorBuffer.ponerTarea(tfin, j)
    END FOR
END PROCESS

//----------------------------------------------------

PROCESS controllerTask(id, monitorBuffer, monitorResultados)
    seguir := true
    
    WHILE seguir DO
        // Obtener tarea del monitor
        t := monitorBuffer.obtenerTarea(id)
        
        IF t.tipoTarea == "TF" THEN
            seguir := false  // Tarea final
        ELSE
            // Determinar tipo de tarea
            IF t.tipoTarea == "t1" THEN
                tipo_idx := 0
                umbral_exito := 5
            ELSE IF t.tipoTarea == "t2" THEN
                tipo_idx := 1
                umbral_exito := 7
            ELSE IF t.tipoTarea == "t3" THEN
                tipo_idx := 2
                umbral_exito := 10
            END IF
            
            // Registrar ejecución
            monitorResultados.registrarEjecucion(tipo_idx)
            
            // Simular procesamiento y posible error
            error := randInt(0, 100)
            IF error > umbral_exito THEN
                // Registrar éxito
                monitorResultados.registrarExito(tipo_idx, t.cargaDeTrabajo)
            END IF
        END IF
    END WHILE
END PROCESS

//====================================================
// PROGRAMA PRINCIPAL
//====================================================

BEGIN
    // Crear monitores
    monitorBuffer := new BufferTareas()
    monitorResultados := new GestionResultados()
    
    // Leer lista de tareas
    listaTareas := leerTareas("tareas.txt")
    
    // Lanzar procesos
    COBEGIN
        masterTask(monitorBuffer, listaTareas)
        ||
        controllerTask(0, monitorBuffer, monitorResultados)
        ||
        controllerTask(1, monitorBuffer, monitorResultados)
        ||
        ...
        ||
        controllerTask(N_CONTROLLERS-1, monitorBuffer, monitorResultados)
    COEND
    
    // Mostrar resultados
    resultados := monitorResultados.obtenerResultados()
    mostrarTablaResultados(resultados)
END